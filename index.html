<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Weblith Manual</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Weblith Manual</h1>
<div class="details">
<span id="revnumber">version 0.1.1-SNAPSHOT,</span>
<span id="revdate">2020-11-29T20:51:40Z</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1. Introduction</a>
<ul class="sectlevel2">
<li><a href="#_a_little_bit_of_history">1.1. A little bit of history</a></li>
<li><a href="#_weblith_goal">1.2. Weblith goal</a></li>
<li><a href="#_why_quarkus_powered">1.3. Why <strong>Quarkus powered</strong> ?</a></li>
</ul>
</li>
<li><a href="#_how_to_use_it">2. How to use it</a></li>
<li><a href="#_routes_and_results">3. Routes and Results</a>
<ul class="sectlevel2">
<li><a href="#_resteasy_integration">3.1. Resteasy integration</a></li>
<li><a href="#_declaring_routes">3.2. Declaring routes</a></li>
<li><a href="#_route_parameters">3.3. Route parameters</a></li>
<li><a href="#_route_results">3.4. Route results</a></li>
</ul>
</li>
<li><a href="#_request_context">4. Request Context</a></li>
<li><a href="#_forms_management">5. Forms Management</a>
<ul class="sectlevel2">
<li><a href="#_form_submission">5.1. Form submission</a></li>
<li><a href="#_form_validation">5.2. Form validation</a></li>
</ul>
</li>
<li><a href="#_freemarker_templates">6. Freemarker Templates</a>
<ul class="sectlevel2">
<li><a href="#_why_freemarker">6.1. Why Freemarker ?</a></li>
<li><a href="#_rendering_templates">6.2. Rendering templates</a></li>
<li><a href="#_injecting_templates">6.3. Injecting templates</a></li>
<li><a href="#_internationalization_support">6.4. Internationalization support</a></li>
</ul>
</li>
<li><a href="#_fomantic_ui_library">7. Fomantic UI library</a>
<ul class="sectlevel2">
<li><a href="#_fomantic_ui_templating">7.1. Fomantic UI templating</a></li>
<li><a href="#_fomantic_ui_components">7.2. Fomantic UI components</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_little_bit_of_history">1.1. A little bit of history</h3>
<div class="paragraph">
<p>At its early stage, Weblith was an internal framework developed at <a href="https://zileo.net">Zileo.net</a> and derived from other frameworks like <a href="http://www.ninjaframework.org">Ninja Framework</a>, <a href="https://github.com/svenkubiak/mangooio">MangooIO</a>, and even <a href="https://spring.io">Spring Boot</a>. The focus was a on rapid (web) application development. Technically, it was based on stable well-known libraries : Google Guice, Lightbend Config, Undertow, Hibernate ORM, Hibernate Validator, Jackson, Freemarker, etc&#8230;&#8203; After one year of production usage, the plan was to open source it (Q3-2020), by creating the missing documentation and archetype, and make it publicly available through <a href="http://weblith.io">a dedicated Weblith.io website</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_weblith_goal">1.2. Weblith goal</h3>
<div class="paragraph">
<p>Weblith has been made to offer a quick and easy way to create <strong>Server Side Rendered</strong> web applications, focusing on fast delivery and developer joy. Opinionated decisions have been taken, allowing to minimize the developer tools needed, reduce the boiler plate code, and even offer nice reusable UI components. It uses stable and well-know libraries to avoid a long learning curve. It will produces one single Jar file with an embedded HTTP server that can run with few technical resources. Note that it doesn&#8217;t reinvent the <strong>monolithic</strong> applications ; depending on the size of your project you should still use micro or external services when it makes sense, even with a front-end application made using Weblith.</p>
</div>
</div>
<div class="sect2">
<h3 id="_why_quarkus_powered">1.3. Why <strong>Quarkus powered</strong> ?</h3>
<div class="paragraph">
<p>Following the news on the Java battlefield, it was very interesting to see <a href="https://quarkus.io">Quakus</a> and <a href="http://micronaut.io">Micronaut</a> emerge. One relevant problem with Weblith was the startup time (mainly slowed by Guice and Hibernate). With the <strong>Quarkus Global Hackathon</strong> launched Q3-2020, there was a good opportunity to try migrating some Weblith layers to Quarkus. With some success, as the Weblith project won the Quarkus Hackathon in the <em>modernize an application</em> category! Now it&#8217;s time for making this project real and open to everyone &#127877;</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_use_it">2. How to use it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A Maven archetype exists, so that you can easily bootstrap a Weblith showcase application. Run this method :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">mvn archetype:generate                      \
  -DarchetypeGroupId=net.zileo              \
  -DarchetypeArtifactId=weblith-archetype   \
  -DarchetypeVersion=0.1.1-SNAPSHOT         \
  -Dversion=1.0.0-SNAPSHOT                  \
  -DgroupId=org.acme                        \
  -DartifactId=my-weblith</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you should be able to <code>cd my-weblith</code> and run <code>mvn compile quarkus:dev</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_routes_and_results">3. Routes and Results</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_resteasy_integration">3.1. Resteasy integration</h3>
<div class="paragraph">
<p>On a purely Quarkus point of view, Weblith works along with the <code>quarkus-resteasy</code> extension. It will automatically register JAX-RS endpoints for your web application routes, as <code>GET</code> and <code>POST</code> resources. By the way, it also means that you can mix Reasteasy code with Weblith if really needed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_declaring_routes">3.2. Declaring routes</h3>
<div class="paragraph">
<p>To declare new routes for your application, you only need to know three annotations : <code>@Controller</code>, <code>@Get</code> and <code>@Post</code>. Each annotation can have a value to represent the corresponding <code>path</code>, or it will be taken automatically from the class name (minus a <code>Controller</code> suffix) or method name.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller
public class MyFirstController {

    @Get
    public Response myPage() { // <b class="conum">(1)</b>
        return Response.ok().build();
    }

    @Get
    public Response myPage2(@PathParam String id) {
        return Response.ok(id).build();
    }

    @Post
    @NotCsrfProtected
    public Response myAction() {
        return Response.ok().build();
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>/MyFirst/myPage</code> (GET)</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">toto++; <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>zerzerze</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Will be recognized as <code>/MyFirst/myPage</code>, <code>/MyFirst/myPage2/{id}</code>,  (GET) and <code>/MyFirst/myAction</code> (POST). <code>Response</code> is the standard JAX-RS returned object ; you&#8217;ll see later that Weblith will help you on that part too.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller("/Controller")
class MySecondController {

    @Get("/page")
    public Response myPage() { ... }

    @Get("/page2/{id}")
    public Response myPage2(@PathParam("id") String identifier) { ... }

    @Post("/action")
    public Response myAction() { ... }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Will be recognized as <code>/Controller/page</code>, <code>/Controller/page/{id}</code> (GET) and <code>/MyFirst/action</code> (POST).</p>
</div>
</div>
<div class="sect2">
<h3 id="_route_parameters">3.3. Route parameters</h3>
<div class="paragraph">
<p>There is no specific annotation for managing parameters of your routes. As you may have noticed on the previous examples, you can use the standard JAX-RS ones : <code>@PathParam</code>, <code>@QueryParam</code>, <code>@HeaderParam</code>, <code>@MatrixParam</code>, <code>@CookieParam</code> and <code>@FormParam</code>. Be sure to import the ones from <code>org.jboss.resteasy.annotations.jaxrs</code> package so that the <code>name</code> of each one is optional (taken from the method parameter name by default). <code>@DefaultValue</code> is also available.</p>
</div>
</div>
<div class="sect2">
<h3 id="_route_results">3.4. Route results</h3>
<div class="paragraph">
<p>While you can configure yourself your JAR-RS <code>Response</code> objects, Weblith offers an handy way to manage the results of your routes via different <code>Result</code> objects :
 * <code>TextResult</code> to render plain text
 * <code>RawResult</code> to render bytes
 * <code>StreamResult</code> to render a <code>File</code> or an <code>URL</code>
 * <code>JsonResult</code> to render some JSON
 * <code>HtmlResult</code> will be addressed in the [Freemarker Templates](=freemarker-templates) chapter</p>
</div>
<div class="paragraph">
<p>Result classes have some shortcut methods to configure the future response, like adding Cookies and changing the charset (<code>UTF-8</code> by default). You can also define your own custom <code>Result</code> classes if needed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    @Get
    public Result myPage() {
        return new TextResult("Hello World").charset(StandardCharsets.UTF_8);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>One last very import one is the <code>Redirect</code> result. All your POST actions will be CSRF-protected (unless marked with @NotCsrfProtected). So GET methods should never be used to modify things ; and successful POST actions should never directly render results, but rather redirect to a GET method, with some optional information. The <code>Redirect</code> result will help you this way.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    @Post
    public Result doIt() {
        return new Redirect("/Test/myPage").withSuccess("You did it !");
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_request_context">4. Request Context</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While in a controller or any other internal service, you can inject a <code>RequestContext</code> instance. This class is a center piece for all request related concepts, and give you access to :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SessionScope</code> : a client-side cookie-based session (server-side session not supporter by Weblith)</p>
</li>
<li>
<p><code>FlashScope</code> : a specific cookie-based scope that keep data from one request to an other</p>
</li>
<li>
<p><code>LocaleHandler</code> : a handler that can detect the current user-defined locale</p>
</li>
<li>
<p><code>seed()</code> and <code>get</code> : a map for storing some objects during the whole request execution</p>
</li>
<li>
<p><code>HttpRequest</code> and <code>UriInfo</code> : JAX-RS request information</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_forms_management">5. Forms Management</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_form_submission">5.1. Form submission</h3>
<div class="paragraph">
<p>While you can use the standard <code>@Form</code> JAX-RS way for getting form information, and the <code>@Valid</code> to throws <code>ConstraintViolationException</code>, Weblith offers a nicer way to manage your forms. Simply embed your form object in a <code>Form</code> parameter like this :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    @Transactional
    @Post
    public Result save(Form&lt;SimpleEntity&gt; form) {
        SimpleEntity dto = form.getValue();
        ... map dto field to real entity instance
        ... save entity
        return new Redirect("/SimpleEntity/list");
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>SimpleEntity</code> object will be filled with your submitted data. It uses a Jackson <code>ObjectMapper</code> underneath that maps a <code>Map</code> of all parameters to the required object.</p>
</div>
</div>
<div class="sect2">
<h3 id="_form_validation">5.2. Form validation</h3>
<div class="paragraph">
<p><code>Form</code> will allow you to trigger the validation of the filled object. All validation (but also parameter conversion) error messages will then be available as a list of <code>Violation</code> objects. Welbith UI components will handle those messages.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    @Transactional
    @Post
    public Result save(Form&lt;SimpleEntity&gt; form) {
        if (!form.validate()) {
            return formTemplate.render(form);
        }
        ...
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_freemarker_templates">6. Freemarker Templates</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_why_freemarker">6.1. Why Freemarker ?</h3>
<div class="paragraph">
<p>During our migration to Quarkus, we tried to reimplement our Freemarker components with Qute, the template engine proposed but the Quarkus team. But it was lacking some features needed for it. As the components base was already well-defined and stable, the choice have been made to continue using Freemarker. <strong>The downsides will be the lack of reactive support (but not intended for Weblith) and the native build support that seems hard to get working.</strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_rendering_templates">6.2. Rendering templates</h3>
<div class="paragraph">
<p>Simply return a <code>HtmlResult</code> to render Freemarker template. This result must point to a template name, and a directory (or the controller name, by default).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    @Get("/")
    public HtmlResult home() {
        return new HtmlResult("Main", "home").render("MyData","MyValue");
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will render the template <code>templates/Main/home.ftlh</code> (stored in the classpath, so in <code>src/main/resources</code>), with a <code>MyData</code> available variable. Some default variables are always added by Weblith :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hostname</code>, <code>requesPath</code> and <code>params</code> : relative to the current request</p>
</li>
<li>
<p><code>contextPath</code> : value of <code>quarkus.http.root-path</code></p>
</li>
<li>
<p><code>lang</code> : current used defined language</p>
</li>
<li>
<p><code>flash</code> : map with current Flash scope data</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Refer to the [Freemarker](<a href="https://freemarker.apache.org/docs/index.html" class="bare">https://freemarker.apache.org/docs/index.html</a>) documentation for more information about how to use this engine.</p>
</div>
</div>
<div class="sect2">
<h3 id="_injecting_templates">6.3. Injecting templates</h3>
<div class="paragraph">
<p>A better way to use templates is to inject instances of <code>FreemarkerTemplate</code> in the controllers. This way, template paths are checked at build-time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller
public class SimpleEntityController {

    @Inject
    FreemarkerTemplate list;

    @Get
    public HtmlResult list() {
        return list.render("SimpleEntities", SimpleEntity.listAll());
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The path of the template will automatically set to <code>templates/SimpleEntityController/list.ftlh</code>. It can be changed by using the <code>@TemplatePath</code> annotation.</p>
</div>
</div>
<div class="sect2">
<h3 id="_internationalization_support">6.4. Internationalization support</h3>
<div class="paragraph">
<p><code>quarkus.locales</code> can be set to the locales supported by the application, and <code>quarkus.default-locale</code> to the default one. Then <code>messages.properties</code> files can be configure in a <code>i18n</code> directory (stored in the classpath, so in <code>src/main/resources</code>). A Weblith <code>LocaleHandler</code> will be used to detect the right language to use, but can be switched by passing a <code>lang</code> parameter to any request (can be changed via <code>quarkus.weblith.switchLanguageParam</code>).</p>
</div>
<div class="paragraph">
<p>While a <code>Messages</code> interface can be injected in any controller of internal service, two methods are also available in the templates :
 * <code>i18n(key,param1,param2,&#8230;&#8203;)</code> : translates the given key
 * <code>prettyTime(date)</code> : displays date relatively</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fomantic_ui_library">7. Fomantic UI library</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_fomantic_ui_templating">7.1. Fomantic UI templating</h3>
<div class="paragraph">
<p>One third Quarkus extension, that will be your real time-saver for building web applications, is a set of Freemarker tags that will allow you to quickly have a nice UI that fits with your Weblith backend code. The archetype you can use to boostrap your application will even offer a primary structure for your own base templates.</p>
</div>
</div>
<div class="sect2">
<h3 id="_fomantic_ui_components">7.2. Fomantic UI components</h3>
<div class="paragraph">
<p>Sadly, this documentation draft do not enter into each component details (too early). But take a quick look at the two following example, as they are pretty clear on what they will produce.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;@page.app title='User list' selectedIcon='users'&gt;
    &lt;@layout.title /&gt;
    &lt;@t.table rows=Users align='left' noButtons=true&gt;
        &lt;@t.column name='role' title='Role' align='center' /&gt;
        &lt;@t.column name='title' title='Title' /&gt;
        &lt;@t.column name='email' title='E-mail' interpret='&lt;@layout.mailto value /&gt;' /&gt;
    &lt;/@t.table&gt;
&lt;/@page.app&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;@f.form 'SimpleEntity' SimpleEntity.id&gt;
    &lt;@f.text name='name' label='Name' required=true /&gt;
    &lt;@f.text name='quantity' label='Quantity' type='number' /&gt;
    &lt;@f.calendar name='date' label='Date' /&gt;
    &lt;@f.buttonBar&gt;
        &lt;@f.cancel /&gt;
        &lt;@f.submit /&gt;
    &lt;/@&gt;
&lt;/@&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.1.1-SNAPSHOT<br>
Last updated 2020-11-29 20:51:28 UTC
</div>
</div>
</body>
</html>